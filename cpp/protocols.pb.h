// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocols.proto

#ifndef PROTOBUF_protocols_2eproto__INCLUDED
#define PROTOBUF_protocols_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
namespace zsearch {
}  // namespace zsearch

namespace zsearch {

namespace protobuf_protocols_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_protocols_2eproto

enum Protocol {
  PROTO_RESERVED = 0,
  PROTO_SYSTEM = 1,
  PROTO_HTTP = 2,
  PROTO_HTTPS = 3,
  PROTO_IMAP = 4,
  PROTO_IMAPS = 5,
  PROTO_SMTP = 6,
  PROTO_SMTPS = 7,
  PROTO_POP3 = 8,
  PROTO_POP3S = 9,
  PROTO_MODBUS = 10,
  PROTO_FTP = 11,
  PROTO_SSH = 12,
  PROTO_DNS = 13,
  PROTO_NTP = 14,
  PROTO_TELNET = 15,
  PROTO_UPNP = 16,
  PROTO_CWMP = 17,
  PROTO_HTTP_2 = 18,
  PROTO_BACNET = 19,
  PROTO_DNP3 = 20,
  PROTO_FOX = 21,
  PROTO_S7 = 22,
  PROTO_GLOBAL = 23,
  PROTO_LOOKUP = 24,
  PROTO_HTTP_WWW = 26,
  PROTO_HTTPS_WWW = 27,
  PROTO_SMB = 28,
  Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Protocol_IsValid(int value);
const Protocol Protocol_MIN = PROTO_RESERVED;
const Protocol Protocol_MAX = PROTO_SMB;
const int Protocol_ARRAYSIZE = Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* Protocol_descriptor();
inline const ::std::string& Protocol_Name(Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    Protocol_descriptor(), value);
}
inline bool Protocol_Parse(
    const ::std::string& name, Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Protocol>(
    Protocol_descriptor(), name, value);
}
enum Subprotocol {
  SUBPROTO_RESERVED = 0,
  SUBPROTO_DELETED = 1,
  SUBPROTO_GENERIC = 2,
  SUBPROTO_BANNER = 3,
  SUBPROTO_TLS = 4,
  SUBPROTO_TLS_1_0 = 5,
  SUBPROTO_TLS_1_1 = 6,
  SUBPROTO_TLS_1_2 = 7,
  SUBPROTO_TLS_1_3 = 8,
  SUBPROTO_HEARTBLEED = 9,
  SUBPROTO_CIPHERS = 10,
  SUBPROTO_SSL_2 = 11,
  SUBPROTO_SSL_3 = 12,
  SUBPROTO_GET = 13,
  SUBPROTO_STARTTLS = 14,
  SUBPROTO_EXPORT = 15,
  SUBPROTO_RSA_EXPORT = 16,
  SUBPROTO_DHE_EXPORT = 17,
  SUBPROTO_DHE = 18,
  SUBPROTO_ECDHE = 19,
  SUBPROTO_SNI = 20,
  SUBPROTO_NO_SNI = 21,
  SUBPROTO_QUIC = 22,
  SUBPROTO_SPDY = 23,
  SUBPROTO_RSA = 24,
  SUBPROTO_DSA = 25,
  SUBPROTO_ECDSA = 26,
  SUBPROTO_DEVICE_ID = 27,
  SUBPROTO_OPEN_RESOLVER = 28,
  SUBPROTO_OPEN_PROXY = 29,
  SUBPROTO_OPEN_RELAY = 30,
  SUBPROTO_TIME = 31,
  SUBPROTO_HACKING_TEAM = 32,
  SUBPROTO_EXTENDED_RANDOM = 33,
  SUBPROTO_DISCOVERY = 34,
  SUBPROTO_GTLD_A = 35,
  SUBPROTO_LOOKUP = 36,
  SUBPROTO_STATUS = 37,
  SUBPROTO_SZL = 38,
  SUBPROTO_V2 = 39,
  SUBPROTO_SYS_PUBLIC_LOCATION = 192,
  SUBPROTO_SYS_AS = 193,
  SUBPROTO_SYS_TAGS = 194,
  SUBPROTO_SYS_METADATA = 195,
  SUBPROTO_SYS_WHOIS = 196,
  SUBPROTO_SYS_USERDATA = 197,
  SUBPROTO_SYS_BLACKLIST = 198,
  SUBPROTO_SYS_ALEXA_RANK = 199,
  SUBPROTO_SYS_RESTRICTED_LOCATION = 200,
  SUBPROTO_SYS_VERSION = 201,
  SUBPROTO_SYS_QUANTCAST_RANK = 202,
  SUBPROTO_SYS_CISCO_UMBRELLA_RANK = 203,
  SUBPROTO_SYS_REVERSE_DNS = 204,
  SUBPROTO_SPF = 220,
  SUBPROTO_DMARC = 221,
  SUBPROTO_DKIM = 222,
  SUBPROTO_A = 223,
  SUBPROTO_MX = 224,
  SUBPROTO_AXFR = 225,
  Subprotocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Subprotocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Subprotocol_IsValid(int value);
const Subprotocol Subprotocol_MIN = SUBPROTO_RESERVED;
const Subprotocol Subprotocol_MAX = SUBPROTO_AXFR;
const int Subprotocol_ARRAYSIZE = Subprotocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* Subprotocol_descriptor();
inline const ::std::string& Subprotocol_Name(Subprotocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    Subprotocol_descriptor(), value);
}
inline bool Subprotocol_Parse(
    const ::std::string& name, Subprotocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Subprotocol>(
    Subprotocol_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


}  // namespace zsearch

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zsearch::Protocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zsearch::Protocol>() {
  return ::zsearch::Protocol_descriptor();
}
template <> struct is_proto_enum< ::zsearch::Subprotocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zsearch::Subprotocol>() {
  return ::zsearch::Subprotocol_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocols_2eproto__INCLUDED
